import React from 'react';
import PropTypes from 'prop-types';
import mergeProps from 'merge-prop-functions';
import ReactTable from 'react-table';
import namor from 'namor';

export const AccessibleReactTableContext = React.createContext();

const { Provider } = AccessibleReactTableContext;

/**
 * Returns the id of the react-table column.
 * In the case of an expander column, which does not have an id, this will return 'rt-expandable'.
 *
 * @param {{id: string?, expander: boolean}} column The react-table column
 * @returns {string} The id of the column.
 */
const getColumnId = column => {
  if (column.id) {
    return column.id;
  }
  return column.expander && 'rt-expandable';
};

/**
 * A function for generating props for a table row group.
 *
 * @returns {{role: string}} The props object for a table row group.
 */
const getCustomTrGroupProps = () => ({
  role: 'rowgroup',
});

/**
 * A function for generating the props for a table row.
 *
 * @returns {{role: string}} The props object for a table row.
 */
const getCustomTrProps = () => ({
  role: 'row',
});

// const exports = module.exports = {};

/**
 * A higher order component function for adding accessibility features to a react-table table.
 *
 * @param {ReactTable} WrappedReactTable The table to wrap with accessibility features.
 * @returns {AccessibleReactTable} The wrapped table that can be used just like a ReactTable.
 */
export function accessibility(WrappedReactTable) {
  /**
   * A higher order component that adds accessibility features to a react-table table.
   *
   * This component has a single child which is the ReactTable being wrapped.
   *
   * This component adds a few additional props for accessibility purposes:
   * <ul>
   *   <li>tableId: String - a unique id for the table for labelling purposes. This is randomly
   *   generated by default.</li>
   *   <li>ariaLabel: String - to apply aria-label to the table.</li>
   *   <li>ariaLabelledBy: String - to apply aria-labelledby to the table</li>
   *   <li>ariaDescribedBy: String - to apply aria-describedby to the table</li>
   * </ul>
   */
  class AccessibleReactTable extends React.Component {
    /**
     * How many many extra rows to count as a header row. Notably, the filter row counts as a
     * header row.
     * @type {number}
     */
    extraHeaderRowCount = this.props.filterable ? 1 : 0;

    /**
     * The default state. This initially only indicates which cell will be focusable.
     * @type {{focused: {row: number, column: number}}}
     */
    state = {
      focused: {
        row: 1 + this.extraHeaderRowCount,
        column: 0,
        managedByChild: false,
      },
    };

    /**
     * Called when the ReactTable is sorted. Updates the state to indicate which column is sorted on.
     * @param {array} sorted An array of the sorted columns.
     */
    onSortedChange = sorted => {
      // Store the react-table sorted data in this components state.
      this.setState({
        sorted: sorted[0],
      });
    };

    /**
     * A function for creating a focus handler function for a table cell.
     *
     * @param {{allVisibleColumns: {array}}} rtState The state object of the ReactTable
     * @param {number} rowIndex The cell's row index.
     * @param {{id: string, expander: boolean}} column The cell's column.
     * @returns {Function} The focus handler function for a table cell.
     */
    onFocus = (rtState, rowIndex, column) => () => {
      console.log('focused row=', rowIndex);
      const columnId = getColumnId(column);
      const newFocused = {
        row: rowIndex,
        column: rtState.allVisibleColumns.findIndex(c => getColumnId(c) === columnId),
      };

      this.setState({
        focused: newFocused,
      });
    };

    /**
     * A function for creating a key down handler function for a table cell.
     *
     * @param {{allVisibleColumns: {array}, endRow: {number}}} rtState The state object of the
     * ReactTable
     * @returns {Function} The key down handler function for a table cell.
     */
    onKeyDown = rtState => e => {
      const columns = rtState.allVisibleColumns;
      let focusedCol = this.state.focused.column;
      let focusedRow = this.state.focused.row;

      // When an appropriate key is pressed, the focused column and/or row index is updated appropriately
      // Except in the case of Enter which simply simulates a click on the cell.

      let changed = false;
      if (e.key === 'ArrowLeft') {
        if (focusedCol > 0) {
          changed = true;
          focusedCol -= 1;
        }
      } else if (e.key === 'ArrowRight') {
        if (focusedCol < columns.length - 1) {
          changed = true;
          focusedCol += 1;
        }
      } else if (e.key === 'ArrowUp') {
        if (focusedRow > 0) {
          changed = true;
          focusedRow -= 1;
        }
      } else if (e.key === 'ArrowDown') {
        if (focusedRow < rtState.endRow + this.extraHeaderRowCount) {
          changed = true;
          focusedRow += 1;
        }
      } else if (e.key === 'Home') {
        // Most upper left cell
        if (e.ctrlKey) {
          if (focusedRow !== 0) {
            changed = true;
            focusedRow = 0;
          }
        }
        if (focusedCol !== 0) {
          changed = true;
          focusedCol = 0;
        }
      } else if (e.key === 'End') {
        // Most bottom right cell
        if (e.ctrlKey) {
          if (focusedRow !== rtState.endRow + this.extraHeaderRowCount) {
            changed = true;
            focusedRow = rtState.endRow + this.extraHeaderRowCount;
          }
        }
        if (focusedCol !== columns.length - 1) {
          changed = true;
          focusedCol = columns.length - 1;
        }
      } else if (e.key === 'PageUp') {
        // Top most cell of current column
        if (focusedRow !== 0) {
          changed = true;
          focusedRow = 0;
        }
      } else if (e.key === 'PageDown') {
        // Bottom most cell of current column
        if (focusedRow !== rtState.endRow + this.extraHeaderRowCount) {
          changed = true;
          focusedRow = rtState.endRow + this.extraHeaderRowCount;
        }
      } else if (e.key === 'Enter') {
        e.target.click();
      }

      if (changed) {
        // If an focused index change occurs, cancel the normal key behavior and focus the new cell.
        e.preventDefault();

        const nodes = document.querySelectorAll(
          `[data-row="${focusedRow}"][data-col="${getColumnId(
            columns[focusedCol]
          )}"][data-parent="${this.props.tableId}"]`
        );
        if (nodes[0]) {
          nodes[0].focus();
        }
      }
    };

    /**
     * Checks whether a cell is focusable based on the given row and column.
     *
     * @param {{allVisibleColumns: {array}}} rtState The state object of the ReactTable
     * @param {number} row The cell's row index.
     * @param {{id: string, expander: boolean}} column The cell's column
     * @returns {boolean} True if the cell is focusable, otherwise false.
     */
    isFocused = (rtState, row, column) => this.isFocused(rtState, row, getColumnId(column));

    isFocusedColId = (rtState, row, columnId) => {
      const focusedRow = this.state.focused.row;
      const focusedCol = this.state.focused.column;

      // TODO Going to have to cache the visible columns...
      return focusedRow === row && getColumnId(rtState.allVisibleColumns[focusedCol]) === columnId;
    };

    /**
     * A function for generating props for a table.
     *
     * @returns {{role: string, 'aria-label': string?, 'aria-labelledby': string?, 'aria-describedby': string?}}
     * The props object for a table.
     */
    getCustomTableProps = () => {
      const props = {
        role: 'grid',
      };

      if (this.props.ariaLabel) {
        props['aria-label'] = this.props.ariaLabel;
      } else if (this.props.ariaLabelledBy) {
        props['aria-labelledby'] = this.props.ariaLabelledBy;
      }

      if (this.props.ariaDescribedBy) {
        props['aria-describedby'] = this.props.ariaDescribedBy;
      }

      return props;
    };

    /**
     * A function for generating props for a table head header.
     *
     * @param {{allVisibleColumns: {array}}} state The state object of the ReactTable component.
     * @param {object} rowInfo Not used.
     * @param {{id: string, expander: boolean}} column The header's column object.
     * @returns {{'aria-sort': string, role: string, tabIndex: number, 'data-row': number, 'data-col': string, 'data-parent': string, onFocus: Function, onKeyDown: Function}}
     * A props object for a table head header.
     */
    getCustomTheadThProps = (state, rowInfo, column) => {
      const { sorted } = this.state;

      // Determine sorted attribute
      let ariaSort;
      if (sorted && column.id === sorted.id) {
        ariaSort = sorted.desc ? 'descending' : 'ascending';
      } else {
        ariaSort = 'none';
      }

      return {
        'aria-sort': ariaSort,
        role: 'columnheader',
        tabIndex: this.isFocused(state, 0, column) ? 0 : -1,
        'data-row': 0,
        'data-col': getColumnId(column),
        'data-parent': this.props.tableId,
        onFocus: this.onFocus(state, 0, column),
        onKeyDown: this.onKeyDown(state),
      };
    };

    /**
     * A function for generating props for a table head filter header.
     *
     * @param {{allVisibleColumns: {array}}} state The state object of the ReactTable component.
     * @param {object} rowInfo Not used.
     * @param {{id: string, expander: boolean}} column The header's column object.
     * @returns {{role: string, tabIndex: number, 'data-row': number, 'data-col': string, 'data-parent': string, onFocus: Function, onKeyDown: Function}}
     * A props object for a table head filter header.
     */
    getCustomTheadFilterThProps = (state, rowInfo, column) => ({
      role: 'columnheader', // TODO proper role here?
      tabIndex: this.isFocused(state, 1, column) ? 0 : -1,
      'data-row': 1,
      'data-col': getColumnId(column),
      'data-parent': this.props.tableId,
      onFocus: this.onFocus(state, 1, column),
      onKeyDown: this.onKeyDown(state),
    });

    /**
     * A function for generating props for a table cell.
     * Notably, it is possible for rowInfo to be undefined, in which case this returns an empty object.
     *
     * @param {{allVisibleColumns: {array}}} state The state object of the ReactTable component.
     * @param {{viewIndex: number}?} rowInfo The cell's row info object.
     * @param {{id: string, expander: boolean}} column The cell's column object.
     * @returns {{role: string, tabIndex: number, 'data-row': number, 'data-col': string, 'data-parent': string, onFocus: Function, onKeyDown: Function}}
     * A props object for a table cell. Possibly an empty object if no rowInfo is given.
     */
    getCustomTdProps = (state, rowInfo, column) => {
      if (rowInfo) {
        const focusable = this.isFocused(
          state,
          rowInfo.viewIndex + 1 + this.extraHeaderRowCount,
          column
        );
        return {
          focusable,
          role: 'gridcell',
          tabIndex: focusable && !this.state.focused.managedByChild ? 0 : -1,
          'data-row': rowInfo.viewIndex + 1 + this.extraHeaderRowCount,
          'data-col': getColumnId(column),
          'data-parent': this.props.tableId,
          onFocus: this.onFocus(state, rowInfo.viewIndex + 1 + this.extraHeaderRowCount, column),
          onKeyDown: this.onKeyDown(state),
          onFocus2: e => {
            console.log(e);
          },
        };
      }
      return {};
    };

    contextualizeCell = (columnId, cellRenderer) => {
      if (cellRenderer) {
        return row => {
          // cell renderer row index has to account for header rows
          const focusable = this.isFocusedColId(
            state,
            row.index + 1 + this.extraHeaderRowCount,
            columnId
          );
          return <Provider value={{ nameAdder: () => {} }}>{cellRenderer(row)}</Provider>;
        };
      }
      return undefined;
    };

    contextualizeColumn = column => {
      let { id } = column;
      if (!id) {
        id = column.accessor;
      }
      return {
        ...column,
        Cell: this.contextualizeCell(id, column.Cell),
        columns: this.contextualizeColumns(column.columns),
      };
    };

    contextualizeColumns = columns => {
      if (columns) {
        return columns.map(this.contextualizeColumn);
      }
      return undefined;
    };

    render() {
      const newProps = { ...this.props };

      // Table parts that use stateless prop callbacks
      newProps.getTheadProps = mergeProps(getCustomTrGroupProps, this.props.getTheadProps);
      newProps.getTbodyProps = mergeProps(getCustomTrGroupProps, this.props.getTbodyProps);
      newProps.getTheadFilterProps = mergeProps(
        getCustomTrGroupProps,
        this.props.getTheadFilterProps
      );
      newProps.getTheadTrProps = mergeProps(getCustomTrProps, this.props.getTheadTrProps);
      newProps.getTheadFilterTrProps = mergeProps(
        getCustomTrProps,
        this.props.getTheadFilterTrProps
      );
      newProps.getTrProps = mergeProps(getCustomTrProps, this.props.getTrProps);

      // Table parts that use stateful prop callbacks
      newProps.getTableProps = mergeProps(this.getCustomTableProps, this.props.getTableProps);
      newProps.getTheadThProps = mergeProps(this.getCustomTheadThProps, this.props.getTheadThProps);
      newProps.getTheadFilterThProps = mergeProps(
        this.getCustomTheadFilterThProps,
        this.props.getTheadFilterThProps
      );
      newProps.getTdProps = mergeProps(this.getCustomTdProps, this.props.getTdProps);

      newProps.columns = this.contextualizeColumns(this.props.columns);

      // ... and renders the wrapped component with the fresh data!
      // Notice that we pass through any additional props
      return <WrappedReactTable {...newProps} onSortedChange={this.onSortedChange} />;
    }
  }

  const myPropTypes = {
    tableId: PropTypes.string,
    ariaLabel: PropTypes.string,
    ariaLabelledBy: PropTypes.string,
    ariaDescribedBy: PropTypes.string,
  };

  const myDefaultProps = {
    tableId: namor.generate({ words: 2 }),
  };

  AccessibleReactTable.propTypes = { ...WrappedReactTable.propTypes, ...myPropTypes };
  AccessibleReactTable.defaultProps = { ...WrappedReactTable.defaultProps, ...myDefaultProps };

  return AccessibleReactTable;
}

/**
 * A pre-wrapped AccessibleReactTable.
 * This cannot be used multiple times in the same page. Instead, the HOC accessibility function must be used.
 */
export default accessibility(ReactTable);
